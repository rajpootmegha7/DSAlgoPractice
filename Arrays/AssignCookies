
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j].
If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. 
Your goal is to maximize the number of your content children and output the maximum number.
Example 1 - 
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.



class Solution {
    
// Solution 1 : Using above approach the complexity will be O(n^2)
    public int findContentChildren(int[] g, int[] s) {
     Arrays.sort(g);Arrays.sort(s);       
       int content = 0;
        for( int i = 0; i < g.length; i++){
            for( int j = 0; j< s.length; j++) {
                
            if(checkContent(g[i], s[j])) {
                content++; 
                break;
            } 
            g[j] = -1;
         }
        }
       return content;
    }
    public boolean checkContent(int g, int s){
        if(s >= g){
            return true;
        }
        return false;
    }
    
    // Solution 2 - Using greedy approach the complexity will be O(n)
    public int findContentChildren(int[] g, int[] s){
        Arrays.sort(g);Arrays.sort(s);
        int nChild = g.length-1, i = 0;
        int nCookie = s.length-1, j = 0;
        int content = 0;
        while (nChild >= i && nCookie >= j){
            if(s[j] >= g[i]){
                i++;
                j++;
                content++;
            }else{
                j++;
            }
        }
        return content;
    }
}
